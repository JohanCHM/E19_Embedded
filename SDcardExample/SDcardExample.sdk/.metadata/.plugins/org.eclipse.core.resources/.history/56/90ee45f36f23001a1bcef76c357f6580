#include <stdio.h>
#include <string.h>
#include "xil_printf.h"
#include "FileSDCard.h"

#define IMGPIX 11078
#define IMG_SIZE 2
#define IMG_FIRST_DATA 10
#define IMGWIDTH
#define IMGHEIGHT

//// super-simplified BMP read algorithm to pull out RGB data
// // read image for coloring scheme
// int image[1024][3]; // first number here is 1024 pixels in my image, 3 is for RGB values
static uint8_t hdr[54];
//static uint8_t readImg[10000];
static uint8_t readImg[IMGPIX];
unsigned int splittedReadImg[IMGPIX][3];
int counter = 0;

void TestReadImg(void){
    int result;
	FileSDCard file((char*)"0:/");

    result = file.mount();
	if (result != XST_SUCCESS) printf("Failed to mount SD card\r\n");

// FILE *streamIn;
// streamIn = fopen("./mybitmap.bmp", "r");
// if (streamIn == (FILE *)0){
//   printf("File opening error ocurred. Exiting program.\n");
//   exit(0);
// }
    // Open created test file
	result = file.open((char*)"geeks.bmp", FA_OPEN_EXISTING | FA_READ);
	if (result != XST_SUCCESS) printf("Failed open file for reading\r\n");

	// Read contents of image file
	result = file.read((void *)hdr, sizeof(hdr), true);
	if (result != XST_SUCCESS) printf("Failed reading header from Img\r\n");

	int imgFileSize = hdr[IMG_SIZE] | hdr[IMG_SIZE + 1] << 8 | hdr[IMG_SIZE + 2] <<16 | hdr[IMG_SIZE + 2] << 24;
	printf("Img File Size : %d bytes\n",imgFileSize);

	int initialDataByte = hdr[IMG_FIRST_DATA] | hdr[IMG_FIRST_DATA + 1] << 8 | hdr[IMG_FIRST_DATA + 2] <<16 | hdr[IMG_FIRST_DATA + 2] << 24;
	printf("Initial Data Byte : %d\n",initialDataByte);

	int imgRealSize = imgFileSize - initialDataByte;
	printf("Img Real Size : %d bytes\n",imgRealSize );


	for(int i=0;i<20;i++){
		printf("header %d : [%x]\n",i+1,hdr[i]);
	}



	result = file.read((void *)readImg, sizeof(readImg), false);
	if (result != XST_SUCCESS) printf("Failed reading Img content\r\n");
	counter = 0;
//	for(int i=830;i<870;i++){    // foreach pixel
//		splittedReadImg[counter][2] = readImg[i];
//		i++;
//		splittedReadImg[counter][1] = readImg[i];
//		i++;
//		splittedReadImg[counter][0] = readImg[i];
//	    printf("pixel %d : [%u]\n",i+1,readImg[i]);
//		}counter++;
//	 }
//
// int byte;
// int count = 0;
// for(i=0;i<54;i++) byte = getc(streamIn);  // strip out BMP header


//
// for(i=0;i<1024;i++){    // foreach pixel
//    image[i][2] = getc(streamIn);  // use BMP 24bit with no alpha channel
//    image[i][1] = getc(streamIn);  // BMP uses BGR but we want RGB, grab byte-by-byte
//    image[i][0] = getc(streamIn);  // reverse-order array indexing fixes RGB issue...
//    printf("pixel %d : [%d,%d,%d]\n",i+1,image[i][0],image[i][1],image[i][2]);
// }
//	result = file.read((void *)readImg, sizeof(readImg), false);
//	if (result != XST_SUCCESS) printf("Failed reading from file\r\n");

//// Carlos Code- BMP has a 54 bytes header
//	for (int i = 78; i < 100; i++)
//	{
//	printf("%u\r\n",(unsigned int)readImg[i]);
//	    /* code */
//	}

	result = file.close();
	if (result != XST_SUCCESS) printf("Failed closing file\r\n");
}



//
// fclose(streamIn);
